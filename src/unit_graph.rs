use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, Serialize)]
pub struct UnitGraph {
    pub version: u32,
    pub units: Vec<Unit>,
    pub roots: Vec<usize>,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct Unit {
    pub pkg_id: String,
    pub target: Target,
    pub profile: Profile,
    pub features: Vec<String>,
    pub mode: String,
    pub dependencies: Vec<Dependency>,
    #[serde(default)]
    pub platform: Option<String>,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct Target {
    pub kind: Vec<String>,
    pub crate_types: Vec<String>,
    pub name: String,
    pub src_path: String,
    pub edition: String,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct Profile {
    pub name: String,
    pub opt_level: String,
    #[serde(default)]
    pub debuginfo: u32,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct Dependency {
    pub index: usize,
    pub extern_crate_name: String,
    #[serde(default)]
    pub public: bool,
}

impl UnitGraph {
    pub fn to_nix(&self) -> String {
        let mut out = String::new();
        out.push_str("# Generated by nix-cargo-unit\n");
        out.push_str("{ pkgs, rustToolchain, src }:\n\n");
        out.push_str("let\n");
        out.push_str("  mkUnit = { pname, edition, crateType, srcPath, deps, features, optLevel }: pkgs.stdenv.mkDerivation {\n");
        out.push_str("    inherit pname;\n");
        out.push_str("    version = \"0.0.0\";\n");
        out.push_str("    \n");
        out.push_str("    buildInputs = deps;\n");
        out.push_str("    nativeBuildInputs = [ rustToolchain ];\n");
        out.push_str("    \n");
        out.push_str("    __contentAddressed = true;\n");
        out.push_str("    outputHashMode = \"recursive\";\n");
        out.push_str("    outputHashAlgo = \"sha256\";\n");
        out.push_str("    \n");
        out.push_str("    buildPhase = ''\n");
        out.push_str("      rustc \\\n");
        out.push_str("        --edition ${edition} \\\n");
        out.push_str("        --crate-type ${crateType} \\\n");
        out.push_str("        -C opt-level=${optLevel} \\\n");
        out.push_str("        ${builtins.concatStringsSep \" \" (map (f: \"--cfg feature=\\\"${f}\\\"\") features)} \\\n");
        out.push_str("        -o $out/lib${pname}.rlib \\\n");
        out.push_str("        ${srcPath}\n");
        out.push_str("    '';\n");
        out.push_str("  };\n\n");

        out.push_str("  units = {\n");
        for (i, unit) in self.units.iter().enumerate() {
            let crate_type = unit.target.crate_types.first().map_or("lib", |s| s.as_str());
            let features_nix: Vec<String> = unit.features.iter().map(|f| format!("\"{f}\"")).collect();

            out.push_str(&format!(
                "    \"{}\" = mkUnit {{\n      pname = \"{}\";\n      edition = \"{}\";\n      crateType = \"{}\";\n      srcPath = \"{}\";\n      deps = [ {} ];\n      features = [ {} ];\n      optLevel = \"{}\";\n    }};\n\n",
                i,
                unit.target.name,
                unit.target.edition,
                crate_type,
                unit.target.src_path,
                unit.dependencies.iter().map(|d| format!("units.\"{}\"", d.index)).collect::<Vec<_>>().join(" "),
                features_nix.join(" "),
                unit.profile.opt_level,
            ));
        }
        out.push_str("  };\n\n");

        out.push_str("in {\n");
        out.push_str("  inherit units;\n");
        out.push_str(&format!(
            "  roots = [ {} ];\n",
            self.roots.iter().map(|r| format!("units.\"{r}\"")).collect::<Vec<_>>().join(" ")
        ));
        out.push_str("}\n");

        out
    }
}
