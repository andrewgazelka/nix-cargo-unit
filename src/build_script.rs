//! Build script (build.rs) detection and derivation generation.
//!
//! Build scripts are special compilation units that execute at build time to configure
//! the main compilation. They output directives like:
//! - `cargo:rustc-cfg=...` - conditional compilation flags
//! - `cargo:rustc-link-lib=...` - libraries to link
//! - `cargo:rustc-link-search=...` - library search paths
//! - `cargo:rustc-env=...` - environment variables for rustc
//! - `cargo:rerun-if-changed=...` - rebuild triggers
//!
//! In nix-cargo-unit, build scripts become two derivations:
//! 1. **Compile derivation**: Compiles build.rs to a binary (same as any other bin)
//! 2. **Run derivation**: Executes the binary and captures output directives
//!
//! The run derivation outputs structured files that [`BuildScriptOutput`] can parse
//! to generate the appropriate rustc flags.

use crate::nix_gen::NixAttrSet;
use crate::rustc_flags::RustcFlags;
use crate::unit_graph::Unit;

/// Parsed output from a build script execution.
///
/// This represents the structured output from a build script run derivation.
/// The files are generated by parsing `cargo:*` directives from the build
/// script's stdout.
#[derive(Debug, Clone, Default, PartialEq, Eq)]
pub struct BuildScriptOutput {
    /// Conditional compilation flags from `cargo:rustc-cfg=...`.
    /// Each entry is a cfg expression like `feature="std"` or `unix`.
    pub rustc_cfgs: Vec<String>,

    /// Libraries to link from `cargo:rustc-link-lib=...`.
    /// Format: `[KIND=]NAME` where KIND is `static`, `framework`, `dylib` (default).
    pub rustc_link_libs: Vec<String>,

    /// Library search paths from `cargo:rustc-link-search=...`.
    /// Format: `[KIND=]PATH` where KIND is `native`, `framework`, `all` (default).
    pub rustc_link_searches: Vec<String>,

    /// Environment variables from `cargo:rustc-env=...`.
    /// Format: `KEY=VALUE`.
    pub rustc_envs: Vec<(String, String)>,

    /// Cdylib-specific linker arguments from `cargo:rustc-cdylib-link-arg=...`.
    pub rustc_cdylib_link_args: Vec<String>,
}

impl BuildScriptOutput {
    /// Parses a single line from one of the build script output files.
    ///
    /// Each file contains one directive value per line (without the `cargo:` prefix).
    fn parse_line(line: &str) -> Option<&str> {
        let trimmed = line.trim();
        if trimmed.is_empty() {
            None
        } else {
            Some(trimmed)
        }
    }

    /// Parses the `rustc-cfg` file contents.
    pub fn parse_cfgs(contents: &str) -> Vec<String> {
        contents
            .lines()
            .filter_map(Self::parse_line)
            .map(String::from)
            .collect()
    }

    /// Parses the `rustc-link-lib` file contents.
    pub fn parse_link_libs(contents: &str) -> Vec<String> {
        contents
            .lines()
            .filter_map(Self::parse_line)
            .map(String::from)
            .collect()
    }

    /// Parses the `rustc-link-search` file contents.
    pub fn parse_link_searches(contents: &str) -> Vec<String> {
        contents
            .lines()
            .filter_map(Self::parse_line)
            .map(String::from)
            .collect()
    }

    /// Parses the `rustc-env` file contents.
    ///
    /// Each line is `KEY=VALUE`. Lines without `=` are skipped.
    pub fn parse_envs(contents: &str) -> Vec<(String, String)> {
        contents
            .lines()
            .filter_map(Self::parse_line)
            .filter_map(|line| {
                let (key, value) = line.split_once('=')?;
                Some((key.to_string(), value.to_string()))
            })
            .collect()
    }

    /// Parses the `rustc-cdylib-link-arg` file contents.
    pub fn parse_cdylib_link_args(contents: &str) -> Vec<String> {
        contents
            .lines()
            .filter_map(Self::parse_line)
            .map(String::from)
            .collect()
    }

    /// Creates a BuildScriptOutput from the contents of all output files.
    ///
    /// This is the main entry point for parsing build script outputs.
    /// Pass empty strings for files that don't exist.
    pub fn from_file_contents(
        cfgs: &str,
        link_libs: &str,
        link_searches: &str,
        envs: &str,
        cdylib_link_args: &str,
    ) -> Self {
        Self {
            rustc_cfgs: Self::parse_cfgs(cfgs),
            rustc_link_libs: Self::parse_link_libs(link_libs),
            rustc_link_searches: Self::parse_link_searches(link_searches),
            rustc_envs: Self::parse_envs(envs),
            rustc_cdylib_link_args: Self::parse_cdylib_link_args(cdylib_link_args),
        }
    }

    /// Returns true if the build script produced no output.
    pub fn is_empty(&self) -> bool {
        self.rustc_cfgs.is_empty()
            && self.rustc_link_libs.is_empty()
            && self.rustc_link_searches.is_empty()
            && self.rustc_envs.is_empty()
            && self.rustc_cdylib_link_args.is_empty()
    }

    /// Generates rustc flags for the parsed output.
    ///
    /// Returns a list of rustc arguments. These should be appended to the
    /// unit's base flags.
    pub fn to_rustc_args(&self) -> Vec<String> {
        let mut args = Vec::new();

        // Add --cfg flags
        for cfg in &self.rustc_cfgs {
            args.push("--cfg".to_string());
            args.push(cfg.clone());
        }

        // Add -l flags for link libs
        for lib in &self.rustc_link_libs {
            args.push("-l".to_string());
            args.push(lib.clone());
        }

        // Add -L flags for link search paths
        for search in &self.rustc_link_searches {
            args.push("-L".to_string());
            args.push(search.clone());
        }

        // Add cdylib link args with -C link-arg
        for arg in &self.rustc_cdylib_link_args {
            args.push("-C".to_string());
            args.push(format!("link-arg={arg}"));
        }

        args
    }

    /// Generates Nix code to read build script outputs and construct rustc flags.
    ///
    /// This generates shell script code that reads from the build script output
    /// derivation and constructs the appropriate flags.
    ///
    /// `build_script_output_var` is the Nix variable referencing the run derivation
    /// (e.g., `"$buildScriptOutput"`).
    pub fn generate_nix_flag_reader(build_script_output_var: &str) -> String {
        let mut script = String::new();

        // Read cfg flags
        script.push_str(&format!(
            r#"# Read build script outputs
if [ -f {var}/rustc-cfg ]; then
  while IFS= read -r cfg; do
    [ -n "$cfg" ] && BUILD_SCRIPT_FLAGS="$BUILD_SCRIPT_FLAGS --cfg $cfg"
  done < {var}/rustc-cfg
fi
"#,
            var = build_script_output_var
        ));

        // Read link libs
        script.push_str(&format!(
            r#"if [ -f {var}/rustc-link-lib ]; then
  while IFS= read -r lib; do
    [ -n "$lib" ] && BUILD_SCRIPT_FLAGS="$BUILD_SCRIPT_FLAGS -l $lib"
  done < {var}/rustc-link-lib
fi
"#,
            var = build_script_output_var
        ));

        // Read link search paths
        script.push_str(&format!(
            r#"if [ -f {var}/rustc-link-search ]; then
  while IFS= read -r search; do
    [ -n "$search" ] && BUILD_SCRIPT_FLAGS="$BUILD_SCRIPT_FLAGS -L $search"
  done < {var}/rustc-link-search
fi
"#,
            var = build_script_output_var
        ));

        // Read cdylib link args
        script.push_str(&format!(
            r#"if [ -f {var}/rustc-cdylib-link-arg ]; then
  while IFS= read -r arg; do
    [ -n "$arg" ] && BUILD_SCRIPT_FLAGS="$BUILD_SCRIPT_FLAGS -C link-arg=$arg"
  done < {var}/rustc-cdylib-link-arg
fi
"#,
            var = build_script_output_var
        ));

        // Export OUT_DIR for generated files
        script.push_str(&format!(
            r#"# Set OUT_DIR for generated code
export OUT_DIR={var}/out-dir
"#,
            var = build_script_output_var
        ));

        script
    }

    /// Generates Nix expression that reads build script outputs at derivation build time.
    ///
    /// Unlike `generate_nix_flag_reader` which generates shell script,
    /// this returns a Nix expression for use in structuredAttrs or similar.
    pub fn generate_nix_expr_reader(build_script_output_var: &str) -> String {
        format!(
            r#"{{
  cfgs = builtins.filter (s: s != "") (lib.strings.splitString "\n" (builtins.readFile ({var} + "/rustc-cfg")));
  linkLibs = builtins.filter (s: s != "") (lib.strings.splitString "\n" (builtins.readFile ({var} + "/rustc-link-lib")));
  linkSearches = builtins.filter (s: s != "") (lib.strings.splitString "\n" (builtins.readFile ({var} + "/rustc-link-search")));
  outDir = {var} + "/out-dir";
}}"#,
            var = build_script_output_var
        )
    }
}

/// Information about a build script unit.
#[derive(Debug, Clone)]
pub struct BuildScriptInfo {
    /// The package that owns this build script.
    pub package_name: String,

    /// Package version.
    pub version: String,

    /// The source path to build.rs (remapped for Nix).
    pub src_path: String,

    /// Unique derivation name for the compiled build script binary.
    pub compile_drv_name: String,

    /// Unique derivation name for the build script execution.
    pub run_drv_name: String,

    /// Rustc flags for compiling the build script.
    pub rustc_flags: RustcFlags,

    /// Features enabled for this build script.
    pub features: Vec<String>,

    /// Whether to use content-addressed derivations.
    pub content_addressed: bool,
}

impl BuildScriptInfo {
    /// Extracts build script information from a unit.
    ///
    /// Returns `None` if the unit is not a build script.
    pub fn from_unit(unit: &Unit, workspace_root: &str, content_addressed: bool) -> Option<Self> {
        if !unit.is_build_script() {
            return None;
        }

        let package_name = unit.package_name().to_string();
        let version = unit.package_version().unwrap_or("0.0.0").to_string();

        // Remap source path
        let src_path =
            crate::source_filter::remap_source_path(&unit.target.src_path, workspace_root, "src");

        // Generate unique derivation names
        let base_hash = unit.identity_hash();
        let compile_drv_name = format!("{package_name}-build-script-{version}-{base_hash}");
        let run_drv_name = format!("{package_name}-build-script-run-{version}-{base_hash}");

        let rustc_flags = RustcFlags::from_unit(unit);

        Some(Self {
            package_name,
            version,
            src_path,
            compile_drv_name,
            run_drv_name,
            rustc_flags,
            features: unit.features.clone(),
            content_addressed,
        })
    }

    /// Generates the Nix derivation for compiling the build script.
    ///
    /// This produces a binary that can be executed.
    pub fn compile_derivation(&self) -> String {
        let mut attrs = NixAttrSet::new();

        attrs.string("pname", &format!("{}-build-script", self.package_name));
        attrs.string("version", &self.version);
        attrs.expr("buildInputs", "[]");
        attrs.expr("nativeBuildInputs", "[ rustToolchain ]");

        if self.content_addressed {
            attrs.bool("__contentAddressed", true);
            attrs.string("outputHashMode", "recursive");
            attrs.string("outputHashAlgo", "sha256");
        }

        let build_phase = self.generate_compile_phase();
        // Use multiline_interpolated so ${src} gets interpolated
        attrs.multiline_interpolated("buildPhase", &build_phase);
        attrs.multiline(
            "installPhase",
            "mkdir -p $out/bin\ncp build/build-script $out/bin/",
        );

        attrs.render(2)
    }

    /// Generates the build phase for compiling the build script.
    fn generate_compile_phase(&self) -> String {
        let mut script = String::new();

        // Build to temp directory first, then copy to $out in installPhase
        script.push_str("mkdir -p build\n\n");

        // Set Cargo environment variables that build scripts may use via env!() at compile time
        script.push_str("# Cargo environment variables for env!() macros\n");
        script.push_str(&format!(
            "export CARGO_PKG_NAME=\"{}\"\n",
            self.package_name
        ));
        script.push_str(&format!("export CARGO_PKG_VERSION=\"{}\"\n", self.version));

        // Parse version components
        let version_parts: Vec<&str> = self.version.split('.').collect();
        let major = version_parts.first().unwrap_or(&"0");
        let minor = version_parts.get(1).unwrap_or(&"0");
        let patch_full = version_parts.get(2).unwrap_or(&"0");
        // Strip any pre-release suffix from patch (e.g., "0-alpha" -> "0")
        let patch = patch_full.split('-').next().unwrap_or("0");

        script.push_str(&format!("export CARGO_PKG_VERSION_MAJOR=\"{}\"\n", major));
        script.push_str(&format!("export CARGO_PKG_VERSION_MINOR=\"{}\"\n", minor));
        script.push_str(&format!("export CARGO_PKG_VERSION_PATCH=\"{}\"\n", patch));
        script.push_str("export CARGO_PKG_VERSION_PRE=\"\"\n");
        script.push_str("export CARGO_PKG_AUTHORS=\"\"\n");
        script.push_str("export CARGO_PKG_DESCRIPTION=\"\"\n");
        script.push_str("export CARGO_PKG_HOMEPAGE=\"\"\n");
        script.push_str("export CARGO_PKG_REPOSITORY=\"\"\n");
        script.push_str("export CARGO_PKG_LICENSE=\"\"\n");
        script.push_str("export CARGO_PKG_LICENSE_FILE=\"\"\n");
        script.push_str("export CARGO_PKG_RUST_VERSION=\"\"\n");
        script.push_str("export CARGO_PKG_README=\"\"\n");

        // Set feature flags as environment variables
        for feature in &self.features {
            let env_name = format!("CARGO_FEATURE_{}", feature.to_uppercase().replace('-', "_"));
            script.push_str(&format!("export {env_name}=1\n"));
        }

        script.push_str("\nrustc \\\n");

        for arg in self.rustc_flags.args() {
            script.push_str("  ");
            if arg.contains(' ') || arg.contains('"') || arg.contains('$') {
                script.push('\'');
                script.push_str(&arg.replace('\'', "'\\''"));
                script.push('\'');
            } else {
                script.push_str(arg);
            }
            script.push_str(" \\\n");
        }

        script.push_str("  ");
        script.push_str(&self.src_path);
        script.push_str(" \\\n");

        // Build script outputs to build/build-script (will be copied to $out in installPhase)
        script.push_str("  -o build/build-script");

        script
    }

    /// Generates the Nix derivation for running the build script.
    ///
    /// This executes the compiled build script and captures its output directives.
    /// The output is stored in structured files:
    /// - `$out/rustc-cfg` - one cfg per line
    /// - `$out/rustc-link-lib` - one lib per line
    /// - `$out/rustc-link-search` - one path per line
    /// - `$out/rustc-env` - KEY=VALUE per line
    /// - `$out/out-dir` - files generated by the build script
    pub fn run_derivation(&self, compile_drv_var: &str) -> String {
        let mut attrs = NixAttrSet::new();

        attrs.string(
            "pname",
            &format!("{}-build-script-output", self.package_name),
        );
        attrs.string("version", &self.version);

        // Depend on the compiled build script
        attrs.expr("buildInputs", &format!("[ {} ]", compile_drv_var));
        attrs.expr("nativeBuildInputs", "[]");

        if self.content_addressed {
            attrs.bool("__contentAddressed", true);
            attrs.string("outputHashMode", "recursive");
            attrs.string("outputHashAlgo", "sha256");
        }

        // Wrap compile_drv_var in ${...} for shell interpolation
        let shell_compile_var = format!("${{{}}}", compile_drv_var);
        let build_phase = self.generate_run_phase(&shell_compile_var);
        // Use multiline_interpolated so ${...} gets interpolated
        attrs.multiline_interpolated("buildPhase", &build_phase);
        attrs.multiline("installPhase", "mkdir -p $out");

        attrs.render(2)
    }

    /// Generates the build phase for running the build script.
    fn generate_run_phase(&self, compile_drv_var: &str) -> String {
        let mut script = String::new();

        // Create output directories
        script.push_str("mkdir -p $out/out-dir\n");

        // Set up environment variables that build scripts expect
        script.push_str("export OUT_DIR=$out/out-dir\n");
        script.push_str(&format!(
            "export CARGO_MANIFEST_DIR=${{src}}/{}\n",
            self.package_name
        ));
        script.push_str(&format!(
            "export CARGO_PKG_NAME=\"{}\"\n",
            self.package_name
        ));
        script.push_str(&format!("export CARGO_PKG_VERSION=\"{}\"\n", self.version));

        // Set feature flags as environment variables
        for feature in &self.features {
            let env_name = format!("CARGO_FEATURE_{}", feature.to_uppercase().replace('-', "_"));
            script.push_str(&format!("export {env_name}=1\n"));
        }

        // Target info (hardcoded for now, should come from config)
        script.push_str("export TARGET=\"$system\"\n");
        script.push_str("export HOST=\"$system\"\n");
        script.push_str("export PROFILE=\"release\"\n");

        // Run the build script and capture output
        script.push_str(&format!(
            "\n# Run build script and parse output\n{}/bin/build-script 2>&1 | while IFS= read -r line; do\n",
            compile_drv_var
        ));

        // Parse cargo: directives
        // Use ''${...} for bash parameter expansion to prevent Nix interpolation
        // ${...} without '' would be interpreted as Nix interpolation
        let parse_script = r#"  case "$line" in
    cargo:rustc-cfg=*)
      echo "''${line#cargo:rustc-cfg=}" >> $out/rustc-cfg
      ;;
    cargo:rustc-link-lib=*)
      echo "''${line#cargo:rustc-link-lib=}" >> $out/rustc-link-lib
      ;;
    cargo:rustc-link-search=*)
      echo "''${line#cargo:rustc-link-search=}" >> $out/rustc-link-search
      ;;
    cargo:rustc-env=*)
      echo "''${line#cargo:rustc-env=}" >> $out/rustc-env
      ;;
    cargo:rustc-cdylib-link-arg=*)
      echo "''${line#cargo:rustc-cdylib-link-arg=}" >> $out/rustc-cdylib-link-arg
      ;;
    cargo:warning=*)
      echo "Build script warning: ''${line#cargo:warning=}" >&2
      ;;
    cargo:rerun-if-changed=*|cargo:rerun-if-env-changed=*)
      # Ignored in Nix (content-addressed handles this)
      ;;
    cargo:*)
      echo "Unknown cargo directive: $line" >&2
      ;;
  esac
done

# Create empty files if they don't exist (for consistent interface)
touch $out/rustc-cfg $out/rustc-link-lib $out/rustc-link-search $out/rustc-env
"#;
        script.push_str(parse_script);

        script
    }
}

/// Checks if a unit is a build script that needs special handling.
pub fn is_build_script_unit(unit: &Unit) -> bool {
    unit.is_build_script()
}

/// Checks if a unit's mode is "run-custom-build" (build script execution).
pub fn is_build_script_run(unit: &Unit) -> bool {
    unit.mode == "run-custom-build"
}

/// Checks if a unit's target kind is "custom-build" (build script compilation).
pub fn is_build_script_compile(unit: &Unit) -> bool {
    unit.target.kind.contains(&"custom-build".to_string())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::unit_graph::UnitGraph;

    fn parse_unit_graph(json: &str) -> UnitGraph {
        serde_json::from_str(json).expect("failed to parse unit graph")
    }

    #[test]
    fn test_build_script_detection() {
        let json = r#"{
            "version": 1,
            "units": [
                {
                    "pkg_id": "my-crate 0.1.0 (path+file:///workspace)",
                    "target": {
                        "kind": ["custom-build"],
                        "crate_types": ["bin"],
                        "name": "build-script-build",
                        "src_path": "/workspace/build.rs",
                        "edition": "2021"
                    },
                    "profile": {"name": "dev", "opt_level": "0"},
                    "features": ["feature-a"],
                    "mode": "run-custom-build",
                    "dependencies": []
                }
            ],
            "roots": [0]
        }"#;

        let graph = parse_unit_graph(json);
        let unit = &graph.units[0];

        assert!(is_build_script_unit(unit));
        assert!(is_build_script_run(unit));
        assert!(is_build_script_compile(unit));

        let info = BuildScriptInfo::from_unit(unit, "/workspace", false);
        assert!(info.is_some());

        let info = info.unwrap();
        assert_eq!(info.package_name, "my-crate");
        assert_eq!(info.version, "0.1.0");
        assert!(info.compile_drv_name.starts_with("my-crate-build-script-"));
        assert!(info.run_drv_name.starts_with("my-crate-build-script-run-"));
        assert_eq!(info.features, vec!["feature-a"]);
    }

    #[test]
    fn test_non_build_script_returns_none() {
        let json = r#"{
            "version": 1,
            "units": [
                {
                    "pkg_id": "my-crate 0.1.0 (path+file:///workspace)",
                    "target": {
                        "kind": ["lib"],
                        "crate_types": ["lib"],
                        "name": "my_crate",
                        "src_path": "/workspace/src/lib.rs",
                        "edition": "2021"
                    },
                    "profile": {"name": "dev", "opt_level": "0"},
                    "features": [],
                    "mode": "build",
                    "dependencies": []
                }
            ],
            "roots": [0]
        }"#;

        let graph = parse_unit_graph(json);
        let unit = &graph.units[0];

        assert!(!is_build_script_unit(unit));
        let info = BuildScriptInfo::from_unit(unit, "/workspace", false);
        assert!(info.is_none());
    }

    #[test]
    fn test_compile_derivation() {
        let json = r#"{
            "version": 1,
            "units": [
                {
                    "pkg_id": "my-crate 0.1.0 (path+file:///workspace)",
                    "target": {
                        "kind": ["custom-build"],
                        "crate_types": ["bin"],
                        "name": "build-script-build",
                        "src_path": "/workspace/build.rs",
                        "edition": "2021"
                    },
                    "profile": {"name": "dev", "opt_level": "0"},
                    "features": [],
                    "mode": "run-custom-build",
                    "dependencies": []
                }
            ],
            "roots": [0]
        }"#;

        let graph = parse_unit_graph(json);
        let unit = &graph.units[0];
        let info = BuildScriptInfo::from_unit(unit, "/workspace", false).unwrap();

        let nix = info.compile_derivation();

        assert!(nix.contains("pname = \"my-crate-build-script\""));
        assert!(nix.contains("version = \"0.1.0\""));
        assert!(nix.contains("rustc"));
        // Build phase outputs to build directory
        assert!(nix.contains("-o build/build-script"));
        // Install phase copies to $out
        assert!(nix.contains("cp build/build-script $out/bin/"));
    }

    #[test]
    fn test_run_derivation() {
        let json = r#"{
            "version": 1,
            "units": [
                {
                    "pkg_id": "my-crate 0.1.0 (path+file:///workspace)",
                    "target": {
                        "kind": ["custom-build"],
                        "crate_types": ["bin"],
                        "name": "build-script-build",
                        "src_path": "/workspace/build.rs",
                        "edition": "2021"
                    },
                    "profile": {"name": "dev", "opt_level": "0"},
                    "features": ["serde"],
                    "mode": "run-custom-build",
                    "dependencies": []
                }
            ],
            "roots": [0]
        }"#;

        let graph = parse_unit_graph(json);
        let unit = &graph.units[0];
        let info = BuildScriptInfo::from_unit(unit, "/workspace", false).unwrap();

        let nix = info.run_derivation("buildScript");

        assert!(nix.contains("pname = \"my-crate-build-script-output\""));
        assert!(nix.contains("buildInputs = [ buildScript ]"));
        assert!(nix.contains("OUT_DIR"));
        assert!(nix.contains("CARGO_FEATURE_SERDE"));
        assert!(nix.contains("cargo:rustc-cfg"));
        assert!(nix.contains("cargo:rustc-link-lib"));
    }

    #[test]
    fn test_content_addressed_build_script() {
        let json = r#"{
            "version": 1,
            "units": [
                {
                    "pkg_id": "my-crate 0.1.0 (path+file:///workspace)",
                    "target": {
                        "kind": ["custom-build"],
                        "crate_types": ["bin"],
                        "name": "build-script-build",
                        "src_path": "/workspace/build.rs",
                        "edition": "2021"
                    },
                    "profile": {"name": "dev", "opt_level": "0"},
                    "features": [],
                    "mode": "run-custom-build",
                    "dependencies": []
                }
            ],
            "roots": [0]
        }"#;

        let graph = parse_unit_graph(json);
        let unit = &graph.units[0];
        let info = BuildScriptInfo::from_unit(unit, "/workspace", true).unwrap();

        let compile_nix = info.compile_derivation();
        assert!(compile_nix.contains("__contentAddressed = true"));
        assert!(compile_nix.contains("outputHashMode = \"recursive\""));

        let run_nix = info.run_derivation("buildScript");
        assert!(run_nix.contains("__contentAddressed = true"));
    }

    // Tests for BuildScriptOutput parsing

    #[test]
    fn test_parse_cfgs() {
        let contents = "unix\nfeature=\"std\"\nfeature=\"alloc\"\n";
        let cfgs = BuildScriptOutput::parse_cfgs(contents);
        assert_eq!(cfgs, vec!["unix", "feature=\"std\"", "feature=\"alloc\""]);
    }

    #[test]
    fn test_parse_cfgs_empty_lines() {
        let contents = "unix\n\nfeature=\"std\"\n  \n";
        let cfgs = BuildScriptOutput::parse_cfgs(contents);
        assert_eq!(cfgs, vec!["unix", "feature=\"std\""]);
    }

    #[test]
    fn test_parse_link_libs() {
        let contents = "ssl\nstatic=z\nframework=CoreFoundation\n";
        let libs = BuildScriptOutput::parse_link_libs(contents);
        assert_eq!(libs, vec!["ssl", "static=z", "framework=CoreFoundation"]);
    }

    #[test]
    fn test_parse_link_searches() {
        let contents = "/usr/lib\nnative=/opt/lib\nframework=/System/Library/Frameworks\n";
        let searches = BuildScriptOutput::parse_link_searches(contents);
        assert_eq!(
            searches,
            vec![
                "/usr/lib",
                "native=/opt/lib",
                "framework=/System/Library/Frameworks"
            ]
        );
    }

    #[test]
    fn test_parse_envs() {
        let contents = "OUT_DIR=/build/out\nTARGET=x86_64-unknown-linux-gnu\nINVALID_LINE\n";
        let envs = BuildScriptOutput::parse_envs(contents);
        assert_eq!(
            envs,
            vec![
                ("OUT_DIR".to_string(), "/build/out".to_string()),
                ("TARGET".to_string(), "x86_64-unknown-linux-gnu".to_string()),
            ]
        );
    }

    #[test]
    fn test_parse_envs_with_equals_in_value() {
        let contents = "MY_VAR=foo=bar=baz\n";
        let envs = BuildScriptOutput::parse_envs(contents);
        assert_eq!(
            envs,
            vec![("MY_VAR".to_string(), "foo=bar=baz".to_string())]
        );
    }

    #[test]
    fn test_parse_cdylib_link_args() {
        let contents = "-Wl,-rpath,/opt/lib\n-lm\n";
        let args = BuildScriptOutput::parse_cdylib_link_args(contents);
        assert_eq!(args, vec!["-Wl,-rpath,/opt/lib", "-lm"]);
    }

    #[test]
    fn test_from_file_contents() {
        let output = BuildScriptOutput::from_file_contents(
            "unix\nfeature=\"std\"\n",
            "ssl\ncrypto\n",
            "/usr/lib\n",
            "MY_VAR=value\n",
            "-Wl,-rpath,/lib\n",
        );

        assert_eq!(output.rustc_cfgs, vec!["unix", "feature=\"std\""]);
        assert_eq!(output.rustc_link_libs, vec!["ssl", "crypto"]);
        assert_eq!(output.rustc_link_searches, vec!["/usr/lib"]);
        assert_eq!(
            output.rustc_envs,
            vec![("MY_VAR".to_string(), "value".to_string())]
        );
        assert_eq!(output.rustc_cdylib_link_args, vec!["-Wl,-rpath,/lib"]);
    }

    #[test]
    fn test_from_file_contents_empty() {
        let output = BuildScriptOutput::from_file_contents("", "", "", "", "");

        assert!(output.is_empty());
        assert!(output.rustc_cfgs.is_empty());
        assert!(output.rustc_link_libs.is_empty());
        assert!(output.rustc_link_searches.is_empty());
        assert!(output.rustc_envs.is_empty());
        assert!(output.rustc_cdylib_link_args.is_empty());
    }

    #[test]
    fn test_to_rustc_args() {
        let output = BuildScriptOutput {
            rustc_cfgs: vec!["unix".to_string(), "feature=\"std\"".to_string()],
            rustc_link_libs: vec!["ssl".to_string(), "static=z".to_string()],
            rustc_link_searches: vec!["/usr/lib".to_string()],
            rustc_envs: vec![("MY_VAR".to_string(), "value".to_string())],
            rustc_cdylib_link_args: vec!["-Wl,-rpath,/lib".to_string()],
        };

        let args = output.to_rustc_args();

        assert!(args.contains(&"--cfg".to_string()));
        assert!(args.contains(&"unix".to_string()));
        assert!(args.contains(&"feature=\"std\"".to_string()));
        assert!(args.contains(&"-l".to_string()));
        assert!(args.contains(&"ssl".to_string()));
        assert!(args.contains(&"static=z".to_string()));
        assert!(args.contains(&"-L".to_string()));
        assert!(args.contains(&"/usr/lib".to_string()));
        assert!(args.contains(&"-C".to_string()));
        assert!(args.contains(&"link-arg=-Wl,-rpath,/lib".to_string()));
    }

    #[test]
    fn test_to_rustc_args_empty() {
        let output = BuildScriptOutput::default();
        let args = output.to_rustc_args();
        assert!(args.is_empty());
    }

    #[test]
    fn test_generate_nix_flag_reader() {
        let script = BuildScriptOutput::generate_nix_flag_reader("$buildScriptOutput");

        assert!(script.contains("$buildScriptOutput/rustc-cfg"));
        assert!(script.contains("$buildScriptOutput/rustc-link-lib"));
        assert!(script.contains("$buildScriptOutput/rustc-link-search"));
        assert!(script.contains("$buildScriptOutput/rustc-cdylib-link-arg"));
        assert!(script.contains("OUT_DIR=$buildScriptOutput/out-dir"));
        assert!(script.contains("BUILD_SCRIPT_FLAGS"));
    }

    #[test]
    fn test_generate_nix_expr_reader() {
        let expr = BuildScriptOutput::generate_nix_expr_reader("buildScriptOutput");

        assert!(expr.contains("cfgs ="));
        assert!(expr.contains("linkLibs ="));
        assert!(expr.contains("linkSearches ="));
        assert!(expr.contains("outDir ="));
        assert!(expr.contains("builtins.readFile"));
        assert!(expr.contains("buildScriptOutput"));
    }

    #[test]
    fn test_is_empty() {
        let empty = BuildScriptOutput::default();
        assert!(empty.is_empty());

        let with_cfg = BuildScriptOutput {
            rustc_cfgs: vec!["unix".to_string()],
            ..Default::default()
        };
        assert!(!with_cfg.is_empty());

        let with_lib = BuildScriptOutput {
            rustc_link_libs: vec!["ssl".to_string()],
            ..Default::default()
        };
        assert!(!with_lib.is_empty());
    }
}
