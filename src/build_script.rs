//! Build script (build.rs) detection and derivation generation.
//!
//! Build scripts are special compilation units that execute at build time to configure
//! the main compilation. They output directives like:
//! - `cargo:rustc-cfg=...` - conditional compilation flags
//! - `cargo:rustc-link-lib=...` - libraries to link
//! - `cargo:rustc-link-search=...` - library search paths
//! - `cargo:rustc-env=...` - environment variables for rustc
//! - `cargo:rerun-if-changed=...` - rebuild triggers
//!
//! In nix-cargo-unit, build scripts become two derivations:
//! 1. **Compile derivation**: Compiles build.rs to a binary (same as any other bin)
//! 2. **Run derivation**: Executes the binary and captures output directives
//!
//! The run derivation outputs structured files that [`BuildScriptOutput`] can parse
//! to generate the appropriate rustc flags.

use crate::nix_gen::{NixAttrSet, generate_cargo_pkg_exports};
use crate::rustc_flags::RustcFlags;
use crate::unit_graph::Unit;

/// Parsed output from a build script execution.
///
/// This represents the structured output from a build script run derivation.
/// The files are generated by parsing `cargo:*` directives from the build
/// script's stdout.
#[derive(Debug, Clone, Default, PartialEq, Eq)]
pub struct BuildScriptOutput {
    /// Conditional compilation flags from `cargo:rustc-cfg=...`.
    /// Each entry is a cfg expression like `feature="std"` or `unix`.
    pub rustc_cfgs: Vec<String>,

    /// Libraries to link from `cargo:rustc-link-lib=...`.
    /// Format: `[KIND=]NAME` where KIND is `static`, `framework`, `dylib` (default).
    pub rustc_link_libs: Vec<String>,

    /// Library search paths from `cargo:rustc-link-search=...`.
    /// Format: `[KIND=]PATH` where KIND is `native`, `framework`, `all` (default).
    pub rustc_link_searches: Vec<String>,

    /// Environment variables from `cargo:rustc-env=...`.
    /// Format: `KEY=VALUE`.
    pub rustc_envs: Vec<(String, String)>,

    /// Cdylib-specific linker arguments from `cargo:rustc-cdylib-link-arg=...`.
    pub rustc_cdylib_link_args: Vec<String>,
}

impl BuildScriptOutput {
    /// Parses a single line from one of the build script output files.
    ///
    /// Each file contains one directive value per line (without the `cargo:` prefix).
    fn parse_line(line: &str) -> Option<&str> {
        let trimmed = line.trim();
        if trimmed.is_empty() {
            None
        } else {
            Some(trimmed)
        }
    }

    /// Parses lines from a build script output file.
    fn parse_lines(contents: &str) -> Vec<String> {
        contents
            .lines()
            .filter_map(Self::parse_line)
            .map(String::from)
            .collect()
    }

    /// Parses the `rustc-cfg` file contents.
    pub fn parse_cfgs(contents: &str) -> Vec<String> {
        Self::parse_lines(contents)
    }

    /// Parses the `rustc-link-lib` file contents.
    pub fn parse_link_libs(contents: &str) -> Vec<String> {
        Self::parse_lines(contents)
    }

    /// Parses the `rustc-link-search` file contents.
    pub fn parse_link_searches(contents: &str) -> Vec<String> {
        Self::parse_lines(contents)
    }

    /// Parses the `rustc-env` file contents.
    ///
    /// Each line is `KEY=VALUE`. Lines without `=` are skipped.
    pub fn parse_envs(contents: &str) -> Vec<(String, String)> {
        contents
            .lines()
            .filter_map(Self::parse_line)
            .filter_map(|line| {
                let (key, value) = line.split_once('=')?;
                Some((key.to_string(), value.to_string()))
            })
            .collect()
    }

    /// Parses the `rustc-cdylib-link-arg` file contents.
    pub fn parse_cdylib_link_args(contents: &str) -> Vec<String> {
        Self::parse_lines(contents)
    }

    /// Creates a BuildScriptOutput from the contents of all output files.
    ///
    /// This is the main entry point for parsing build script outputs.
    /// Pass empty strings for files that don't exist.
    pub fn from_file_contents(
        cfgs: &str,
        link_libs: &str,
        link_searches: &str,
        envs: &str,
        cdylib_link_args: &str,
    ) -> Self {
        Self {
            rustc_cfgs: Self::parse_cfgs(cfgs),
            rustc_link_libs: Self::parse_link_libs(link_libs),
            rustc_link_searches: Self::parse_link_searches(link_searches),
            rustc_envs: Self::parse_envs(envs),
            rustc_cdylib_link_args: Self::parse_cdylib_link_args(cdylib_link_args),
        }
    }

    /// Returns true if the build script produced no output.
    pub fn is_empty(&self) -> bool {
        self.rustc_cfgs.is_empty()
            && self.rustc_link_libs.is_empty()
            && self.rustc_link_searches.is_empty()
            && self.rustc_envs.is_empty()
            && self.rustc_cdylib_link_args.is_empty()
    }

    /// Generates rustc flags for the parsed output.
    ///
    /// Returns a list of rustc arguments. These should be appended to the
    /// unit's base flags.
    pub fn to_rustc_args(&self) -> Vec<String> {
        let mut args = Vec::new();

        // Add --cfg flags
        for cfg in &self.rustc_cfgs {
            args.push("--cfg".to_string());
            args.push(cfg.clone());
        }

        // Add -l flags for link libs
        for lib in &self.rustc_link_libs {
            args.push("-l".to_string());
            args.push(lib.clone());
        }

        // Add -L flags for link search paths
        for search in &self.rustc_link_searches {
            args.push("-L".to_string());
            args.push(search.clone());
        }

        // Add cdylib link args with -C link-arg
        for arg in &self.rustc_cdylib_link_args {
            args.push("-C".to_string());
            args.push(format!("link-arg={arg}"));
        }

        args
    }

    /// Generates Nix code to read build script outputs and construct rustc flags.
    ///
    /// Generates shell snippet to read a build script output file and append flags.
    fn flag_reader_snippet(var: &str, filename: &str, flag_format: &str) -> String {
        format!(
            r#"if [ -f {var}/{filename} ]; then
  while IFS= read -r line; do
    [ -n "$line" ] && BUILD_SCRIPT_FLAGS="$BUILD_SCRIPT_FLAGS {flag_format}"
  done < {var}/{filename}
fi
"#,
            var = var,
            filename = filename,
            flag_format = flag_format
        )
    }

    /// This generates shell script code that reads from the build script output
    /// derivation and constructs the appropriate flags.
    ///
    /// `build_script_output_var` is the Nix variable referencing the run derivation
    /// (e.g., `"$buildScriptOutput"`).
    pub fn generate_nix_flag_reader(build_script_output_var: &str) -> String {
        let var = build_script_output_var;
        let mut script = String::from("# Read build script outputs\n");

        script.push_str(&Self::flag_reader_snippet(var, "rustc-cfg", "--cfg $line"));
        script.push_str(&Self::flag_reader_snippet(
            var,
            "rustc-link-lib",
            "-l $line",
        ));
        script.push_str(&Self::flag_reader_snippet(
            var,
            "rustc-link-search",
            "-L $line",
        ));
        script.push_str(&Self::flag_reader_snippet(
            var,
            "rustc-cdylib-link-arg",
            "-C link-arg=$line",
        ));

        // Export OUT_DIR for generated files
        script.push_str(&format!(
            r#"# Set OUT_DIR for generated code
export OUT_DIR={var}/out-dir
"#,
            var = var
        ));

        script
    }

    /// Generates Nix expression that reads build script outputs at derivation build time.
    ///
    /// Unlike `generate_nix_flag_reader` which generates shell script,
    /// this returns a Nix expression for use in structuredAttrs or similar.
    pub fn generate_nix_expr_reader(build_script_output_var: &str) -> String {
        format!(
            r#"{{
  cfgs = builtins.filter (s: s != "") (lib.strings.splitString "\n" (builtins.readFile ({var} + "/rustc-cfg")));
  linkLibs = builtins.filter (s: s != "") (lib.strings.splitString "\n" (builtins.readFile ({var} + "/rustc-link-lib")));
  linkSearches = builtins.filter (s: s != "") (lib.strings.splitString "\n" (builtins.readFile ({var} + "/rustc-link-search")));
  outDir = {var} + "/out-dir";
}}"#,
            var = build_script_output_var
        )
    }
}

/// Information about a build script unit.
#[derive(Debug, Clone)]
pub struct BuildScriptInfo {
    /// The package that owns this build script.
    pub package_name: String,

    /// Package version.
    pub version: String,

    /// The target name (e.g., "build-script-build").
    /// Used to locate the compiled binary in the compile derivation.
    pub target_name: String,

    /// The source path to build.rs (remapped for Nix).
    pub src_path: String,

    /// The manifest directory (CARGO_MANIFEST_DIR), remapped for Nix.
    /// This is the directory containing Cargo.toml for this crate.
    pub manifest_dir: String,

    /// Unique derivation name for the compiled build script binary.
    pub compile_drv_name: String,

    /// Unique derivation name for the build script execution.
    pub run_drv_name: String,

    /// Rustc flags for compiling the build script.
    pub rustc_flags: RustcFlags,

    /// Features enabled for this build script.
    pub features: Vec<String>,

    /// Whether to use content-addressed derivations.
    pub content_addressed: bool,
}

impl BuildScriptInfo {
    /// Extracts build script information from a unit.
    ///
    /// Returns `None` if the unit is not a build script.
    pub fn from_unit(unit: &Unit, workspace_root: &str, content_addressed: bool) -> Option<Self> {
        if !unit.is_build_script() {
            return None;
        }

        let package_name = unit.package_name().to_string();
        let version = unit.package_version().unwrap_or("0.0.0").to_string();
        let target_name = unit.target.name.clone();

        // Remap source path
        let src_path =
            crate::source_filter::remap_source_path(&unit.target.src_path, workspace_root, "src");

        // Remap manifest directory (CARGO_MANIFEST_DIR)
        let manifest_dir =
            crate::source_filter::remap_manifest_dir(unit, workspace_root, "src", "vendorDir");

        // Generate unique derivation names
        let base_hash = unit.identity_hash();
        let compile_drv_name = format!("{package_name}-build-script-{version}-{base_hash}");
        let run_drv_name = format!("{package_name}-build-script-run-{version}-{base_hash}");

        let rustc_flags = RustcFlags::from_unit(unit);

        Some(Self {
            package_name,
            version,
            target_name,
            src_path,
            manifest_dir,
            compile_drv_name,
            run_drv_name,
            rustc_flags,
            features: unit.features.clone(),
            content_addressed,
        })
    }

    /// Generates the Nix derivation for compiling the build script.
    ///
    /// This produces a binary that can be executed.
    pub fn compile_derivation(&self) -> String {
        let mut attrs = NixAttrSet::new();

        attrs.string("pname", &format!("{}-build-script", self.package_name));
        attrs.string("version", &self.version);
        attrs.expr("buildInputs", "[]");
        attrs.expr(
            "nativeBuildInputs",
            "[ rustToolchain ] ++ extraNativeBuildInputs",
        );

        if self.content_addressed {
            attrs.add_ca_attrs();
        }

        let build_phase = self.generate_compile_phase();
        // Use multiline_interpolated so ${src} gets interpolated
        attrs.multiline_interpolated("buildPhase", &build_phase);
        attrs.multiline(
            "installPhase",
            r#"[ -f "$out/bin/build-script" ] || {
  mkdir -p $out/bin
  cp build/build-script $out/bin/
  chmod 755 $out/bin/build-script
}"#,
        );

        attrs.render(2)
    }

    /// Generates the build phase for compiling the build script.
    fn generate_compile_phase(&self) -> String {
        let mut script = String::new();

        // Build to temp directory first, then copy to $out in installPhase
        script.push_str("mkdir -p build\n\n");

        // Set Cargo environment variables that build scripts may use via env!() at compile time
        script.push_str(&generate_cargo_pkg_exports(
            &self.package_name,
            &self.version,
            &self.features,
        ));

        script.push_str("\nrustc \\\n");

        for arg in self.rustc_flags.args() {
            script.push_str("  ");
            script.push_str(&crate::shell::quote_arg(arg));
            script.push_str(" \\\n");
        }

        script.push_str("  ");
        script.push_str(&self.src_path);
        script.push_str(" \\\n");

        // Build script outputs to build/build-script (will be copied to $out in installPhase)
        script.push_str("  -o build/build-script");

        script
    }

    /// Generates the Nix derivation for running the build script.
    ///
    /// This executes the compiled build script and captures its output directives.
    /// The output is stored in structured files:
    /// - `$out/rustc-cfg` - one cfg per line
    /// - `$out/rustc-link-lib` - one lib per line
    /// - `$out/rustc-link-search` - one path per line
    /// - `$out/rustc-env` - KEY=VALUE per line
    /// - `$out/out-dir` - files generated by the build script
    /// - `$out/links` - the `links` value from Cargo.toml (if present)
    /// - `$out/cargo-metadata` - generic cargo:<key>=<value> metadata
    ///
    /// The `dep_build_script_outputs` parameter lists Nix variable names for
    /// dependency build script outputs. These are used to set DEP_<LINKS>_<KEY>
    /// environment variables for the build script.
    pub fn run_derivation(
        &self,
        compile_drv_var: &str,
        dep_build_script_outputs: &[String],
    ) -> String {
        let mut attrs = NixAttrSet::new();

        attrs.string(
            "pname",
            &format!("{}-build-script-output", self.package_name),
        );
        attrs.string("version", &self.version);

        // Depend on the compiled build script AND dependency build script outputs
        let mut build_inputs = vec![compile_drv_var.to_string()];
        build_inputs.extend(dep_build_script_outputs.iter().cloned());
        attrs.expr("buildInputs", &format!("[ {} ]", build_inputs.join(" ")));

        // Include rustToolchain for build scripts that query rustc (e.g., rustversion)
        // and extraNativeBuildInputs for tools like protoc that run during build script execution
        attrs.expr(
            "nativeBuildInputs",
            "[ rustToolchain ] ++ extraNativeBuildInputs",
        );

        if self.content_addressed {
            attrs.add_ca_attrs();
        }

        // Wrap compile_drv_var in ${...} for shell interpolation
        let shell_compile_var = format!("${{{}}}", compile_drv_var);
        let build_phase = self.generate_run_phase(&shell_compile_var, dep_build_script_outputs);
        // Use multiline_interpolated so ${...} gets interpolated
        attrs.multiline_interpolated("buildPhase", &build_phase);
        attrs.multiline("installPhase", "[ -d \"$out\" ] || mkdir -p $out");

        attrs.render(2)
    }

    /// Generates the build phase for running the build script.
    fn generate_run_phase(
        &self,
        compile_drv_var: &str,
        dep_build_script_outputs: &[String],
    ) -> String {
        let mut script = String::new();

        // Create output directories (conditional for CA-derivation reuse)
        script.push_str("[ -d \"$out/out-dir\" ] || mkdir -p $out/out-dir\n");

        // Set up environment variables that build scripts expect
        script.push_str("export OUT_DIR=$out/out-dir\n");

        // CARGO_MANIFEST_DIR is the directory containing Cargo.toml for this crate
        // This is pre-computed with proper remapping for workspace vs vendored crates
        script.push_str(&format!(
            "export CARGO_MANIFEST_DIR=\"{}\"\n",
            self.manifest_dir
        ));

        // Extract 'links' field from Cargo.toml for DEP_* variable passing
        // This is used by dependent build scripts to receive cargo metadata
        script.push_str(&format!(
            r#"
# Extract links field from Cargo.toml (for DEP_* variable passing)
LINKS_VALUE=$(sed -n 's/^links[[:space:]]*=[[:space:]]*"\([^"]*\)".*/\1/p' "{0}/Cargo.toml" | head -1)
if [ -n "$LINKS_VALUE" ]; then
  echo "$LINKS_VALUE" > $out/links
fi
"#,
            self.manifest_dir
        ));

        // Import DEP_<LINKS>_<KEY>=<value> from dependency build script outputs
        // Each dependency that has a 'links' file will have its cargo-metadata
        // exported as DEP_<LINKS>_<KEY> environment variables
        for dep_var in dep_build_script_outputs {
            // dep_var is like "units.\"pkg-build-script-run-X.Y.Z-hash\""
            // In shell, we interpolate it as ${units."pkg-build-script-run-X.Y.Z-hash"}
            // Use ''${ to escape shell variables from Nix interpolation
            script.push_str(&format!(
                r#"
# Import DEP_* from {0}
if [ -f "${{{0}}}/links" ]; then
  _DEP_LINKS=$(cat "${{{0}}}/links")
  _DEP_LINKS_UPPER=$(echo "$_DEP_LINKS" | tr '[:lower:]' '[:upper:]' | tr '-' '_')
  if [ -f "${{{0}}}/cargo-metadata" ]; then
    while IFS='=' read -r key value; do
      key_upper=$(echo "$key" | tr '[:lower:]' '[:upper:]' | tr '-' '_')
      export "DEP_''${{_DEP_LINKS_UPPER}}_''${{key_upper}}=$value"
    done < "${{{0}}}/cargo-metadata"
  fi
fi
"#,
                dep_var
            ));
        }

        // Set Cargo package environment variables
        script.push_str(&generate_cargo_pkg_exports(
            &self.package_name,
            &self.version,
            &self.features,
        ));

        // Rust compiler and target info
        // Map Nix system names to Rust target triples
        script.push_str("export RUSTC=\"$(type -p rustc)\"\n");
        script.push_str(
            r#"case "$system" in
  aarch64-darwin)
    TARGET="aarch64-apple-darwin"
    CARGO_CFG_TARGET_ARCH="aarch64"
    CARGO_CFG_TARGET_OS="macos"
    CARGO_CFG_TARGET_FAMILY="unix"
    CARGO_CFG_TARGET_VENDOR="apple"
    CARGO_CFG_TARGET_ENV=""
    CARGO_CFG_TARGET_POINTER_WIDTH="64"
    CARGO_CFG_TARGET_ENDIAN="little"
    CARGO_CFG_UNIX=""
    ;;
  x86_64-darwin)
    TARGET="x86_64-apple-darwin"
    CARGO_CFG_TARGET_ARCH="x86_64"
    CARGO_CFG_TARGET_OS="macos"
    CARGO_CFG_TARGET_FAMILY="unix"
    CARGO_CFG_TARGET_VENDOR="apple"
    CARGO_CFG_TARGET_ENV=""
    CARGO_CFG_TARGET_POINTER_WIDTH="64"
    CARGO_CFG_TARGET_ENDIAN="little"
    CARGO_CFG_UNIX=""
    ;;
  aarch64-linux)
    TARGET="aarch64-unknown-linux-gnu"
    CARGO_CFG_TARGET_ARCH="aarch64"
    CARGO_CFG_TARGET_OS="linux"
    CARGO_CFG_TARGET_FAMILY="unix"
    CARGO_CFG_TARGET_VENDOR="unknown"
    CARGO_CFG_TARGET_ENV="gnu"
    CARGO_CFG_TARGET_POINTER_WIDTH="64"
    CARGO_CFG_TARGET_ENDIAN="little"
    CARGO_CFG_UNIX=""
    ;;
  x86_64-linux)
    TARGET="x86_64-unknown-linux-gnu"
    CARGO_CFG_TARGET_ARCH="x86_64"
    CARGO_CFG_TARGET_OS="linux"
    CARGO_CFG_TARGET_FAMILY="unix"
    CARGO_CFG_TARGET_VENDOR="unknown"
    CARGO_CFG_TARGET_ENV="gnu"
    CARGO_CFG_TARGET_POINTER_WIDTH="64"
    CARGO_CFG_TARGET_ENDIAN="little"
    CARGO_CFG_UNIX=""
    ;;
  *)
    TARGET="$system"
    CARGO_CFG_TARGET_ARCH=""
    CARGO_CFG_TARGET_OS=""
    CARGO_CFG_TARGET_FAMILY=""
    CARGO_CFG_TARGET_VENDOR=""
    CARGO_CFG_TARGET_ENV=""
    CARGO_CFG_TARGET_POINTER_WIDTH=""
    CARGO_CFG_TARGET_ENDIAN=""
    ;;
esac
export TARGET HOST="$TARGET"
export CARGO_CFG_TARGET_ARCH CARGO_CFG_TARGET_OS CARGO_CFG_TARGET_FAMILY
export CARGO_CFG_TARGET_VENDOR CARGO_CFG_TARGET_ENV
export CARGO_CFG_TARGET_POINTER_WIDTH CARGO_CFG_TARGET_ENDIAN
export CARGO_CFG_UNIX
"#,
        );
        script.push_str("export PROFILE=\"release\"\n");
        // Add DEBUG and OPT_LEVEL for build scripts that check optimization settings
        script.push_str("export DEBUG=\"false\"\n");
        script.push_str("export OPT_LEVEL=\"3\"\n");

        // Run the build script and capture output
        // The binary name matches the target name (typically "build-script-build")
        // Use a temporary file to avoid pipefail issues with failing build scripts
        // NOTE: We cd to CARGO_MANIFEST_DIR because some build scripts read Cargo.toml
        // from the current directory rather than from CARGO_MANIFEST_DIR env var
        script.push_str(&format!(
            "\n# Run build script from package directory (some read Cargo.toml from cwd)\n\
            cd \"$CARGO_MANIFEST_DIR\"\n\
            BUILD_SCRIPT_OUTPUT=$(mktemp)\n\
            set +e\n\
            {}/bin/{} > \"$BUILD_SCRIPT_OUTPUT\" 2>&1\n\
            BUILD_SCRIPT_EXIT=$?\n\
            set -e\n\n\
            # Parse cargo directives from output\n\
            while IFS= read -r line; do\n",
            compile_drv_var, self.target_name
        ));

        // Parse cargo: directives
        // Use ''${...} for bash parameter expansion to prevent Nix interpolation
        // ${...} without '' would be interpreted as Nix interpolation
        let parse_script = r#"  case "$line" in
    cargo:rustc-cfg=*)
      echo "''${line#cargo:rustc-cfg=}" >> $out/rustc-cfg
      ;;
    cargo:rustc-link-lib=*)
      echo "''${line#cargo:rustc-link-lib=}" >> $out/rustc-link-lib
      ;;
    cargo:rustc-link-search=*)
      echo "''${line#cargo:rustc-link-search=}" >> $out/rustc-link-search
      ;;
    cargo:rustc-env=*)
      echo "''${line#cargo:rustc-env=}" >> $out/rustc-env
      ;;
    cargo:rustc-cdylib-link-arg=*)
      echo "''${line#cargo:rustc-cdylib-link-arg=}" >> $out/rustc-cdylib-link-arg
      ;;
    cargo:warning=*)
      echo "Build script warning: ''${line#cargo:warning=}" >&2
      ;;
    cargo:rerun-if-changed=*|cargo:rerun-if-env-changed=*)
      # Ignored in Nix (content-addressed handles this)
      ;;
    cargo:*)
      # Capture generic cargo metadata (key=value) for DEP_* passing
      # These become DEP_<LINKS>_<KEY>=<value> for dependent build scripts
      meta="''${line#cargo:}"
      if [[ "$meta" == *"="* ]]; then
        echo "$meta" >> $out/cargo-metadata
      fi
      ;;
  esac
done < "$BUILD_SCRIPT_OUTPUT"

# Create empty files if they don't exist (for consistent interface)
# Use conditional touch to handle CA-derivation reuse where $out may already exist read-only
for f in rustc-cfg rustc-link-lib rustc-link-search rustc-env cargo-metadata; do
  [ -f "$out/$f" ] || touch "$out/$f"
done

# Exit with build script's exit code only if it actually failed
if [ $BUILD_SCRIPT_EXIT -ne 0 ]; then
  echo "Build script exited with code $BUILD_SCRIPT_EXIT" >&2
  echo "=== Build script output ===" >&2
  cat "$BUILD_SCRIPT_OUTPUT" >&2
  echo "=== End build script output ===" >&2
  rm -f "$BUILD_SCRIPT_OUTPUT"
  exit $BUILD_SCRIPT_EXIT
fi

rm -f "$BUILD_SCRIPT_OUTPUT"
"#;
        script.push_str(parse_script);

        script
    }
}

/// Checks if a unit is a build script that needs special handling.
pub fn is_build_script_unit(unit: &Unit) -> bool {
    unit.is_build_script()
}

/// Checks if a unit's mode is "run-custom-build" (build script execution).
pub fn is_build_script_run(unit: &Unit) -> bool {
    unit.mode == "run-custom-build"
}

/// Checks if a unit's target kind is "custom-build" (build script compilation).
pub fn is_build_script_compile(unit: &Unit) -> bool {
    unit.target.kind.contains(&"custom-build".to_string())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::unit_graph::parse_test_unit_graph;

    #[test]
    fn test_build_script_detection() {
        let json = r#"{
            "version": 1,
            "units": [
                {
                    "pkg_id": "my-crate 0.1.0 (path+file:///workspace)",
                    "target": {
                        "kind": ["custom-build"],
                        "crate_types": ["bin"],
                        "name": "build-script-build",
                        "src_path": "/workspace/build.rs",
                        "edition": "2021"
                    },
                    "profile": {"name": "dev", "opt_level": "0"},
                    "features": ["feature-a"],
                    "mode": "run-custom-build",
                    "dependencies": []
                }
            ],
            "roots": [0]
        }"#;

        let graph = parse_test_unit_graph(json);
        let unit = &graph.units[0];

        assert!(is_build_script_unit(unit));
        assert!(is_build_script_run(unit));
        assert!(is_build_script_compile(unit));

        let info = BuildScriptInfo::from_unit(unit, "/workspace", false);
        assert!(info.is_some());

        let info = info.unwrap();
        assert_eq!(info.package_name, "my-crate");
        assert_eq!(info.version, "0.1.0");
        assert!(info.compile_drv_name.starts_with("my-crate-build-script-"));
        assert!(info.run_drv_name.starts_with("my-crate-build-script-run-"));
        assert_eq!(info.features, vec!["feature-a"]);
    }

    #[test]
    fn test_non_build_script_returns_none() {
        let json = r#"{
            "version": 1,
            "units": [
                {
                    "pkg_id": "my-crate 0.1.0 (path+file:///workspace)",
                    "target": {
                        "kind": ["lib"],
                        "crate_types": ["lib"],
                        "name": "my_crate",
                        "src_path": "/workspace/src/lib.rs",
                        "edition": "2021"
                    },
                    "profile": {"name": "dev", "opt_level": "0"},
                    "features": [],
                    "mode": "build",
                    "dependencies": []
                }
            ],
            "roots": [0]
        }"#;

        let graph = parse_test_unit_graph(json);
        let unit = &graph.units[0];

        assert!(!is_build_script_unit(unit));
        let info = BuildScriptInfo::from_unit(unit, "/workspace", false);
        assert!(info.is_none());
    }

    #[test]
    fn test_compile_derivation() {
        let json = r#"{
            "version": 1,
            "units": [
                {
                    "pkg_id": "my-crate 0.1.0 (path+file:///workspace)",
                    "target": {
                        "kind": ["custom-build"],
                        "crate_types": ["bin"],
                        "name": "build-script-build",
                        "src_path": "/workspace/build.rs",
                        "edition": "2021"
                    },
                    "profile": {"name": "dev", "opt_level": "0"},
                    "features": [],
                    "mode": "run-custom-build",
                    "dependencies": []
                }
            ],
            "roots": [0]
        }"#;

        let graph = parse_test_unit_graph(json);
        let unit = &graph.units[0];
        let info = BuildScriptInfo::from_unit(unit, "/workspace", false).unwrap();

        let nix = info.compile_derivation();

        assert!(nix.contains("pname = \"my-crate-build-script\""));
        assert!(nix.contains("version = \"0.1.0\""));
        assert!(nix.contains("rustc"));
        // Build phase outputs to build directory
        assert!(nix.contains("-o build/build-script"));
        // Install phase copies to $out
        assert!(nix.contains("cp build/build-script $out/bin/"));
    }

    #[test]
    fn test_run_derivation() {
        let json = r#"{
            "version": 1,
            "units": [
                {
                    "pkg_id": "my-crate 0.1.0 (path+file:///workspace)",
                    "target": {
                        "kind": ["custom-build"],
                        "crate_types": ["bin"],
                        "name": "build-script-build",
                        "src_path": "/workspace/build.rs",
                        "edition": "2021"
                    },
                    "profile": {"name": "dev", "opt_level": "0"},
                    "features": ["serde"],
                    "mode": "run-custom-build",
                    "dependencies": []
                }
            ],
            "roots": [0]
        }"#;

        let graph = parse_test_unit_graph(json);
        let unit = &graph.units[0];
        let info = BuildScriptInfo::from_unit(unit, "/workspace", false).unwrap();

        let nix = info.run_derivation("buildScript", &[]);

        assert!(nix.contains("pname = \"my-crate-build-script-output\""));
        assert!(nix.contains("buildInputs = [ buildScript ]"));
        assert!(nix.contains("OUT_DIR"));
        assert!(nix.contains("CARGO_FEATURE_SERDE"));
        assert!(nix.contains("cargo:rustc-cfg"));
        assert!(nix.contains("cargo:rustc-link-lib"));
    }

    #[test]
    fn test_content_addressed_build_script() {
        let json = r#"{
            "version": 1,
            "units": [
                {
                    "pkg_id": "my-crate 0.1.0 (path+file:///workspace)",
                    "target": {
                        "kind": ["custom-build"],
                        "crate_types": ["bin"],
                        "name": "build-script-build",
                        "src_path": "/workspace/build.rs",
                        "edition": "2021"
                    },
                    "profile": {"name": "dev", "opt_level": "0"},
                    "features": [],
                    "mode": "run-custom-build",
                    "dependencies": []
                }
            ],
            "roots": [0]
        }"#;

        let graph = parse_test_unit_graph(json);
        let unit = &graph.units[0];
        let info = BuildScriptInfo::from_unit(unit, "/workspace", true).unwrap();

        let compile_nix = info.compile_derivation();
        assert!(compile_nix.contains("__contentAddressed = true"));
        assert!(compile_nix.contains("outputHashMode = \"recursive\""));

        let run_nix = info.run_derivation("buildScript", &[]);
        assert!(run_nix.contains("__contentAddressed = true"));
    }

    // Tests for BuildScriptOutput parsing

    #[test]
    fn test_parse_cfgs() {
        let contents = "unix\nfeature=\"std\"\nfeature=\"alloc\"\n";
        let cfgs = BuildScriptOutput::parse_cfgs(contents);
        assert_eq!(cfgs, vec!["unix", "feature=\"std\"", "feature=\"alloc\""]);
    }

    #[test]
    fn test_parse_cfgs_empty_lines() {
        let contents = "unix\n\nfeature=\"std\"\n  \n";
        let cfgs = BuildScriptOutput::parse_cfgs(contents);
        assert_eq!(cfgs, vec!["unix", "feature=\"std\""]);
    }

    #[test]
    fn test_parse_link_libs() {
        let contents = "ssl\nstatic=z\nframework=CoreFoundation\n";
        let libs = BuildScriptOutput::parse_link_libs(contents);
        assert_eq!(libs, vec!["ssl", "static=z", "framework=CoreFoundation"]);
    }

    #[test]
    fn test_parse_link_searches() {
        let contents = "/usr/lib\nnative=/opt/lib\nframework=/System/Library/Frameworks\n";
        let searches = BuildScriptOutput::parse_link_searches(contents);
        assert_eq!(
            searches,
            vec![
                "/usr/lib",
                "native=/opt/lib",
                "framework=/System/Library/Frameworks"
            ]
        );
    }

    #[test]
    fn test_parse_envs() {
        let contents = "OUT_DIR=/build/out\nTARGET=x86_64-unknown-linux-gnu\nINVALID_LINE\n";
        let envs = BuildScriptOutput::parse_envs(contents);
        assert_eq!(
            envs,
            vec![
                ("OUT_DIR".to_string(), "/build/out".to_string()),
                ("TARGET".to_string(), "x86_64-unknown-linux-gnu".to_string()),
            ]
        );
    }

    #[test]
    fn test_parse_envs_with_equals_in_value() {
        let contents = "MY_VAR=foo=bar=baz\n";
        let envs = BuildScriptOutput::parse_envs(contents);
        assert_eq!(
            envs,
            vec![("MY_VAR".to_string(), "foo=bar=baz".to_string())]
        );
    }

    #[test]
    fn test_parse_cdylib_link_args() {
        let contents = "-Wl,-rpath,/opt/lib\n-lm\n";
        let args = BuildScriptOutput::parse_cdylib_link_args(contents);
        assert_eq!(args, vec!["-Wl,-rpath,/opt/lib", "-lm"]);
    }

    #[test]
    fn test_from_file_contents() {
        let output = BuildScriptOutput::from_file_contents(
            "unix\nfeature=\"std\"\n",
            "ssl\ncrypto\n",
            "/usr/lib\n",
            "MY_VAR=value\n",
            "-Wl,-rpath,/lib\n",
        );

        assert_eq!(output.rustc_cfgs, vec!["unix", "feature=\"std\""]);
        assert_eq!(output.rustc_link_libs, vec!["ssl", "crypto"]);
        assert_eq!(output.rustc_link_searches, vec!["/usr/lib"]);
        assert_eq!(
            output.rustc_envs,
            vec![("MY_VAR".to_string(), "value".to_string())]
        );
        assert_eq!(output.rustc_cdylib_link_args, vec!["-Wl,-rpath,/lib"]);
    }

    #[test]
    fn test_from_file_contents_empty() {
        let output = BuildScriptOutput::from_file_contents("", "", "", "", "");

        assert!(output.is_empty());
        assert!(output.rustc_cfgs.is_empty());
        assert!(output.rustc_link_libs.is_empty());
        assert!(output.rustc_link_searches.is_empty());
        assert!(output.rustc_envs.is_empty());
        assert!(output.rustc_cdylib_link_args.is_empty());
    }

    #[test]
    fn test_to_rustc_args() {
        let output = BuildScriptOutput {
            rustc_cfgs: vec!["unix".to_string(), "feature=\"std\"".to_string()],
            rustc_link_libs: vec!["ssl".to_string(), "static=z".to_string()],
            rustc_link_searches: vec!["/usr/lib".to_string()],
            rustc_envs: vec![("MY_VAR".to_string(), "value".to_string())],
            rustc_cdylib_link_args: vec!["-Wl,-rpath,/lib".to_string()],
        };

        let args = output.to_rustc_args();

        assert!(args.contains(&"--cfg".to_string()));
        assert!(args.contains(&"unix".to_string()));
        assert!(args.contains(&"feature=\"std\"".to_string()));
        assert!(args.contains(&"-l".to_string()));
        assert!(args.contains(&"ssl".to_string()));
        assert!(args.contains(&"static=z".to_string()));
        assert!(args.contains(&"-L".to_string()));
        assert!(args.contains(&"/usr/lib".to_string()));
        assert!(args.contains(&"-C".to_string()));
        assert!(args.contains(&"link-arg=-Wl,-rpath,/lib".to_string()));
    }

    #[test]
    fn test_to_rustc_args_empty() {
        let output = BuildScriptOutput::default();
        let args = output.to_rustc_args();
        assert!(args.is_empty());
    }

    #[test]
    fn test_generate_nix_flag_reader() {
        let script = BuildScriptOutput::generate_nix_flag_reader("$buildScriptOutput");

        assert!(script.contains("$buildScriptOutput/rustc-cfg"));
        assert!(script.contains("$buildScriptOutput/rustc-link-lib"));
        assert!(script.contains("$buildScriptOutput/rustc-link-search"));
        assert!(script.contains("$buildScriptOutput/rustc-cdylib-link-arg"));
        assert!(script.contains("OUT_DIR=$buildScriptOutput/out-dir"));
        assert!(script.contains("BUILD_SCRIPT_FLAGS"));
    }

    #[test]
    fn test_generate_nix_expr_reader() {
        let expr = BuildScriptOutput::generate_nix_expr_reader("buildScriptOutput");

        assert!(expr.contains("cfgs ="));
        assert!(expr.contains("linkLibs ="));
        assert!(expr.contains("linkSearches ="));
        assert!(expr.contains("outDir ="));
        assert!(expr.contains("builtins.readFile"));
        assert!(expr.contains("buildScriptOutput"));
    }

    #[test]
    fn test_is_empty() {
        let empty = BuildScriptOutput::default();
        assert!(empty.is_empty());

        let with_cfg = BuildScriptOutput {
            rustc_cfgs: vec!["unix".to_string()],
            ..Default::default()
        };
        assert!(!with_cfg.is_empty());

        let with_lib = BuildScriptOutput {
            rustc_link_libs: vec!["ssl".to_string()],
            ..Default::default()
        };
        assert!(!with_lib.is_empty());
    }
}
